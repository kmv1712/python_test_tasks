jewelry, stones =  input(), input()
print(len([i for i in stones if i in jewelry]))


# Подумать не укладываюсь в 1с и 10мб
сount_int = int(input())
total = sorted(set([input() for i in range(count_int)]))
for j in total:
	print(j)


count_int = int(input())
list_with_input_int = []
for i in range(count_int):
    user_input = int(input()) 
    if not user_input in list_with_input_int:
        list_with_input_int.append(user_input)
list_with_input_int.sort()
for j in list_with_input_int:
    print(j)

# print('\n'.join(map(lambda x: str(x), list_with_input_int)))

# Укладываюсь в 1с и 10мб
# время 483ms
for j in sorted(list(set(int(input()) for i in range(int(input()))))):
    print(j)

# время 490ms
count_int = int(input())
for j in sorted(list(set(int(input()) for i in range(count_int)))):
    print(j)

# Удивительно, но не укладываюсь в 10мб, я думал что без list быстрее, но оказалось set сортируется дольше
count_int = int(input())
for j in sorted(set(int(input()) for i in range(count_int))):
    print(j)

# Анаграммы 
print(int(sorted(list(input())) == sorted(list(input()))))

# Самая длинная последовательность едениц
print(len(max(''.join([input() for i in range(int(input()))]).split('0'))))

def quicksort(array):
    if len(array) < 2:
        return array
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot]
        greater = [i for i in array[1:] if i > pivot]
        return quicksort(less) + [pivot] + quicksort(greater)

# Быстрая сортировка
list_all = []

for i in range(int(input())):
    list_all.extend(list(map(lambda x: int(x), input().split(' ')[1:])))

for j in quicksort(list_all):
    print(j, end=' ')

