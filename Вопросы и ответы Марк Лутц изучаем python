стр.77

стр.163

стр.205

стр.218

стр.301

стр.323 Обзор и сводка по основным типам (повторять)

стр.330

В качестве эмпирического правила запомните: операция == является тем, что вы
будете использовать для почти всех проверок эквивалентности, тогда как операция is
зарезервирована для очень специализированных ролей.

стр.334.Таблица типов объекта
стр.339 Вопросы по типам.
стр.393
стр.409 Вопросы по Y if X else Z ((X AND Y) OR Z)

стр.427 качестве общего правила запомните: всякий раз, когда это возможно, применяйте for вместо while, и не используйте вызовы range в циклах for кроме крайних случаев. Более простое решение практически всегда будет лучшим

стр.437 вопросы по while for

>>> def f(a, b, c, d): print('{}{}{}{}'.format(a,b,c,d))
...
>>> f(1, 2, 3, 4)
1234
>>> f(*[1, 2, 3, 4])
1234
>>> f(**{'a':1, 'b':2, 'c':3, 'd':4})
1234
>>> q = [1, 2, 3, 4]
>>> f(*q)
1234

стр.465 Вопросы по итераторам

стр.488 Вопросы по выводу документации

стр.503 вопросы о функциях

стр.539 вопросы о области видимости


стр.596 вопросы по lambda, map, filter, reduce

стр.644 вопросы о генераторных включениях и функциях

стр.651 закладка

20.11.2020
  стр.694
02.12.2020
  стр.709
07.12.2020
  стр.720 Читаю про импорт в python
08.12.2020
  стр.743 Читаю про абсолютный, относительный импорт в python
10.12.2020
  стр.760 Читал про импорт, модулей, пакетов
14.12.2020
  Прочитал 1 том
  
16.12.2020
  стр.44 Читаю про перегрузку, наследование в python
  
17.12.2020
  стр.55 читаю про классы

22.12.2020
  стр.69 Читаю про ООП, про переопределение методов, про методы __init__, __repr__, __str__

25.12.2020
  стр.80


19.01.2021
  стр.101
  
20.01.2021
  стр.112

21.01.2021
  стр.116
 
22.01.2021
  стр. 130 Читал про __getitem__, __index__, slice()
  
23.01.2021
  стр. 138 Читал про __iter__, __next__

27.01.2021
  стр .162 Читал про __add__, __radd__, __iadd__, __str__, __repr__, __call__
 
28.01.2021
  стр.168 Читал про __lt__, __gt__, __cmp__, __bool__, __len__, __del__
  
01.02.2021
  стр.191 Читал про Паттерн проектирования фабрика, про различные вызовы объектов

02.02.2021
  стр.211 Прочитал про собирающий модуль, про вывод списка аттрибутов в дереве классов

09.02.2021
  стр.224 Пока сам не понял что прочитал) Вроде про разину классов в python2 и python3 что в python 3 все наследуется от object
  
10.02.2021
  стр. 234 Читал про разницу классов в python 2 и 3 говорилось о том, что в python 3 все наследуется от object поэтому все классы имеют встроенный набор методов, так же расмматривалась разница сравнения классов и применение методов  __getattr__  и __getitem__

11.02.2021
############################################################################################
  в python 2 DFLR(Depth-First, Left-to-Right) - сначала в глубину, слева направо
  в python 3 MRO(Method Resolution Order) - сначала в ширину слева направо потом в глубь. Поиск проходит по уровням. Не смотря на название применяется для всех атрибутов, а не только методов. 

  в python 3
  class A:
  ...     attr = 1
  ... 
  class B(A):
  ...     pass
  ... class C(A):
  ...     attr = 2
  ... class D(B,C):
  ...     pass
  ... 
  x = D()
  x.attr 
  2 # x, D, B, C
  в python 2
  1 # x, D, B, A

  Очередность прохода по наследуемым классам, можно изменить

  в python 2
  class D(B,C):
      attr = C.attr
  в python 3
  class D(B,C):
      attr = B.attr

  Class.__mro__ - покажет все наследуемые классы в порядке прохождения 

  Class.__bases__ - покажет наследуемые классы только этим класом

  в python 3
  class X: pass
  ... class Y: pass
  ... class A(X): pass
  ... class B(Y): pass 
  ... class D(A, B): pass
  ... 
  D.mro()
  [<class '__main__.D'>, <class '__main__.A'>, <class '__main__.X'>, <class '__main__.B'>, <class '__main__.Y'>, <class 'object'>]

  __slots__ - позволяем классу нового стиля ограничить набор допусимых атрибутов, которые могут иметь экземпляры этого класса, а также оптимизировать потребление памяти и возможно скорость работы программы. Использовать надо только в приложениях в которых добавочная сложность очевидно оправдана. Они усложняют код, могут нарушить работу кода.
  Средство слотов задумавалось как способ отлавливания опечаток, а также как механихм оптимиации

  class limiter(object):
  ...     __slots__ = ['age', 'name', 'job']

  x = limter()

  x.age
  Traceback (most recent call last):
    File "<input>", line 1, in <module>
  AttributeError: age

  x.age = 40
  x.age
  40
  x.ape = 1000
  Traceback (most recent call last):
    File "<input>", line 1, in <module>
  AttributeError: 'limiter' object has no attribute 'ape'

  Начиная с версии Python 3.3, требования к пространству атрибутов, не хра­
  нящихся в слотах, были понижены с помощью модели словарей с разделяемы­
  ми ключами, где словари __dict__ , используемые для атрибутов объектов,
  могут разделять часть их внутреннего хранилища, в том числе хранилища
  ключей. Это может уменьшить ценность __slots__ как инструмента оп­
  тимизации; согласно эталонным тестам такое изменение сокращает пот­
  ребление памяти на 10-20% для объектно-ориентированных программ,
  показывает небольшое улучшение в скорости для программ, которые
  создают много похожих объектов, и в будущем вероятно продолжит оп­
  тимизироваться. С другой стороны, данное средство отнюдь не отменяет
  присутствия__ slots__ в существующем коде, с которым вам, возможно,
  предстоит разбираться!
  
  стр.248
  ---############################################################################################
