стр.205

Резюме

В главе был проведен экскурс в типы числовых объектов Python и операции, кото-
рые к ним можно применять. Попутно мы исследовали стандартные целочисленные

типы и типы с плавающей точкой, а также ряд более экзотических и менее распро-
страненных типов наподобие комплексных чисел, десятичных чисел, дробей и мно-
жеств. Мы обсудили синтаксис выражений Python, преобразования между типами,

побитовые операции и разнообразные литеральные формы для записи чисел в сце-
нариях.

Далее в этой части книги мы продолжим подробный обзор типов, восполняя не-
достающие детали об очередном типе объектов — строке. Однако в следующей главе

мы займемся исследованием присваивания переменных. Оно представляет собой, по-
жалуй, наиболее фундаментальную идею в Python, поэтому обязательно ознакомьтесь

со следующей главой, прежде чем двигаться дальше. А сейчас наступило время для
традиционных контрольных вопросов.
Проверьте свои знания: контрольные вопросы
1. Каким будет значение выражения 2 * (3 + 4) в Python?
2. Каким будет значение выражения 2 ★ 3 + 4 в Python?
3. Каким будет значение выражения 2 + 3 * 4 в Python?
4. Какие инструменты можно использовать для нахождения квадратного корня и
квадрата числа?
5. Каким будет тип результата выражения 1 + 2 . О + 3?
6. Как можно усекать и округлять число с плавающей точкой?
7. Как можно преобразовывать целое число в число с плавающей точкой?
8. Как можно отображать целое число в восьмеричной, шестнадцатеричной или
двоичной форме?
9. Как можно преобразовывать строку восьмеричных, шестнадцатеричных или
двоичных цифр в простое целое число?
Проверьте свои знания: ответы

1. Значением выражения будет 14, результат 2*7, поскольку круглые скобки при-
водят к выполнению сложения раньше умножения.

2. Значением выражения будет 10, результат 6 + 4. В отсутствие круглых скобок

применяются правила старшинства операций Python, а согласно табл. 5.2 умно-
жение имеет более высокий приоритет, чем сложение.

3. Значением выражения будет 14, результат 2 + 12, по тем же причинам старшин-
ства, что и в предыдущем ответе.

Глава 5. Числовые типы 205

4. Функции для получения квадратного корня, а также числа пи, тангенсов и мно-
гого другого доступны в импортируемом модуле math. Чтобы найти квадратный

корень числа, импортируйте math и вызовите math, sqrt (N). Для нахождения
квадрата числа используйте либо выражение возведения в степень X * * 2, либо
встроенную функцию pow (X, 2). Любой из двух последних приемов позволяет
также вычислить квадратный корень в случае указания степени 0.5 (например,
X** .5).

5. Результатом будет число с плавающей точкой: целые числа преобразуются в чис-
ла с плавающей точкой (наиболее сложный тип в выражении) и для вычисления

применяется математика с плавающей точкой.

6. Усечение производят функции int (N) и math, trune (N), а округление — функ-
ция round (N, digits). Можно также округлять в меньшую сторону с помощью

math, floor (N) и округлять для отображения посредством операций формати-
рования строк.

7. Функция float (I) преобразует целое число в число с плавающей точкой; сме-
шивание целых чисел и чисел с плавающей точкой внутри выражения также

приводит к преобразованию. В определенном смысле операция деления / из

Python З.Х также производит преобразование — она всегда возвращает резуль-
тат, который содержит остаток, даже если оба операнда являются целыми.

8. Встроенные функции oct (1) и hex (I) возвращают для целого числа строковые
представления в восьмеричной и шестнадцатеричной формах. Вызов bin (I)

возвращает строку с двоичными цифрами в Python 2.6, 3.0 и последующих вер-
сиях. Операция форматирования строк % и строковый метод format также поз-
воляют выполнять подобные преобразования.

9. Для преобразования строк восьмеричных, шестнадцатеричных и двоичных
цифр в нормальные целые числа можно использовать функцию int (S, base),
передавая ей в качестве основания системы счисления (base) соответственно
8, 16 и 2. Для той же самой цели можно применять и функцию eval (S), но она
сопряжена с более высокими затратами и проблемами в плане безопасности.
Обратите внимание, что в памяти компьютера целые числа всегда хранятся в
двоичной форме; преобразования происходят просто в целях отображения.

стр.218

Резюме
В главе мы более подробно рассмотрели модель динамической типизации Python —
т.е. способ, которым Python автоматически отслеживает типы объектов, не требуя от
нас написания операторов объявлений в сценариях. Попутно вы узнали, каким образом
переменные и объекты связываются ссылками в Python; также обсуждалась идея сборки

мусора, было показано, как разделяемые ссылки могут влиять на множество перемен-
ных, и приведены объяснения воздействия ссылок на понятие равенства в Python.

Поскольку в Python имеется лишь одна модель присваивания и оттого, что при-
сваивание вездесуще в языке, важно понять данную модель, прежде чем двигаться

дальше. Следующие контрольные вопросы должны помочь вам закрепить некоторые

идеи, изложенные в главе. Затем мы возобновим наш тур по основным объектам, пе-
рейдя к рассмотрению строк.

Проверьте свои знания: контрольные вопросы
1. Взгляните на следующие три оператора. Изменяют ли они значение, выводимое для А?
А = "spam”
В - А
В = "shrubbery"

2. Взгляните на приведенные ниже три оператора. Изменяют ли они значение, вы-
водимое для А?

А = ["spam"]
В = А
В[0] = "shrubbery"
3. Как насчет показанных далее трех операторов — изменяется ли А теперь?
А= ["spam"]
В = А[:]
В[0] = "shrubbery"

Проверьте свои знания: ответы
1. Нет: для А по-прежнему выводится "spam". Когда В присваивается строка

"shrubbery", все что происходит — переменная В переустанавливается для ука-
зания на новый строковый объект. А и В изначально разделяются, т.е. указывают

на тот же самый одиночный строковый объект "spam", но в Python два имени
никогда не связываются вместе. Таким образом, установка В в другой объект не
оказывает влияния на А. Кстати, то же самое справедливо, если бы последним

оператором здесь был В == В + ' shrubbery’ — конкатенация привела бы к созда-
нию в качестве своего результата нового объекта, который затем был бы при-
своен только В. Мы не можем перезаписывать строку (либо число или кортеж)

на месте, потому что строки неизменяемы.

2. Да: теперь для А выводится [ "shrubbery" ]. Формально мы на самом деле не из-
меняем ни А, ни В; взамен мы модифицируем часть объекта, на который ссыла-
ются обе переменные (указывают на него), перезаписывая этот объект на месте

через переменную В. Поскольку А ссылается на тот же самый объект, что и В,
обновление отражается также в А.
3. Нет: для А по-прежнему выводится [ "spam" ]. Присваивание на месте через В на

этот раз не оказывает воздействия, т.к. выражение среза создает копию списко-
вого объекта до его присваивания переменной В. После второго оператора при-
сваивания существуют два разных списковых объекта, которые имеют одинако-
вые значения (в Python они дают True при выполнении операции ==, но не is).

Третий оператор изменяет значение спискового объекта, на который указывает В,
но не того, на который указывает А.

Резюме

В главе мы более подробно рассмотрели строковые объекты. Вы узнали о напи-
сании строковых литералов и ознакомились со строковыми операциями, включая

операции над последовательностями, вызовы строковых методов и форматирование

строк посредством выражений и вызовов методов. Попутно вы более глубоко изучи-
ли разнообразные концепции, такие как нарезание, синтаксис вызовов методов и

блочные строки в утроенных кавычках. Были также определены некоторые основные
идеи, общие для множества типов: например, последовательности разделяют целый
набор операций.

В следующей главе мы продолжим наше путешествие по типам исследованием на-
иболее универсальных коллекций объектов в Python — списков и словарей. Как вы

обнаружите, многое из того, что уже изучено до сих пор, будет также применимо и к

этим типам. Ранее упоминалось о том, что в финальной части книги мы еще возвра-
тимся к модели строк Python, чтобы конкретизировать детали, связанные с текстом

Unicode и двоичными данными, которые интересны далеко не всем программистам

на Python. Тем не менее, прежде чем двигаться дальше, вот традиционные контроль-
ные вопросы, которые помогут закрепить пройденный материал.

Проверьте свои знания: контрольные вопросы
1. Можно ли использовать строковый метод find для поиска в списке?
2. Можно ли применять выражение среза строки для списка?
3. Как бы вы преобразовали символ в его целочисленный код ASCII? Как бы вы
выполнили обратное преобразование из целого числа в символ?
4. Как бы вы могли изменить строку в Python?
5. Для заданной строки S со значением "s,pa,in" назовите два способа извлечения
двух символов из середины строки.
6. Сколько символов имеется в строке "a\nb\xlf\000d"?
7. Почему вы использовали бы модуль string вместо вызова строковых методов?

266 Часть II. Типы и операции

Проверьте свои знания: ответы
1. Нет, потому что методы всегда специфичны для типа, т.е. работают только с

единственным типом данных. Однако выражения вроде X+Y и встроенные фун-
кции наподобие len (X) являются универсальными и способны работать на мно-
жестве типов. В этом случае выражение членства in дает результат, аналогич-
ный строковому методу find, но может применяться для поиска и в строках, и

в списках. В Python З.Х была предпринята попытка сгруппировать методы по
категориям (скажем, изменяемые типы последовательностей list и bytearray
имеют похожие наборы методов), но методы по-прежнему более специфичны к
типам, чем другие наборы операций.
2. Да. В отличие от методов выражения универсальны и применимы ко многим
типам. В данном случае выражение среза на самом деле является операцией над
последовательностями — оно работает на объектах последовательностей любого
типа, включая строки, списки и кортежи. Единственное отличие связано с тем,
что при нарезании списка обратно получается новый список.

3. Встроенная функция ord (S) преобразует односимвольную строку в целочислен-
ный код символа; chr (I) преобразует целочисленный код в строку. Тем не ме-
нее, имейте в виду, что эти целые числа являются лишь кодами ASCII ддя текста,

чьи символы извлекаются только из таблицы символов ASCII. В модели Unicode

строки текста фактически представляют собой последовательности кодовых то-
чек Unicode, идентифицируемые целыми числами, которые могут выходить за

пределы 7-битного диапазона чисел, зарезервированного кодировкой ASCII (до-
полнительные сведения о строках Unicode ищите в главах 4 и 37).

4. Строки не могут быть модифицированы; они неизменяемы. Однако похожего

результата можно добиться путем создания новой строки — за счет конкатена-
ции, нарезания, выполнения выражений форматирования либо использования

вызова метода, подобного replace, — и затем присваивания результата исход-
ной переменной.

5. Можно получить срез строки с применением S [ 2 : 4 ] или разбить строку по за-
пятой и индексировать результат, используя S. split (’, ’) [1]. Чтобы удостове-
риться в этом, опробуйте приемы в интерактивной подсказке.

6. Шесть. Строка "a\nb\xlf\000d" содержит символ а, символ новой строки

(\п), литеральное значение 31 (шестнадцатеричная управляющая последова-
тельность \xlf), литеральное значение 0 (восьмеричная управляющая последо-
вательность \000) и символ d. Передайте строку встроенной функции len, что-
бы проверить это, и выведите результаты функции ord для каждого ее символа,

чтобы увидеть действительные значения кодовых точек (идентифицирующих
чисел). Управляющие последовательности были описаны в табл. 7.2.

7. В наши дни вы никогда не должны применять модуль string вместо вызова ме-
тодов строковых объектов — он объявлен устаревшим и в Python З.Х его вызовы

полностью устранены. Единственной веской причиной использования модуля

string на сегодняшний день являются остальные его инструменты, такие как за-
ранее определенные константы. Вы также можете заметить, что модуль string

встречается в очень старом, покрывшемся толстым слоем пыли коде Python (и в
книгах из туманного прошлого вроде 1990-х годов).

стр.301

материал.

300 Часть II. Типы и операции

Проверьте свои знания: контрольные вопросы
1. Назовите два способа построения списка, содержащего пять целочисленных нулей.

2. Назовите два способа построения словаря с двумя ключами, ’ а ’ и ’Ь’, с каж-
дым из которых ассоциировано значение 0.

3. Назовите четыре операции, которые изменяют списковый объект на месте.
4. Назовите четыре операции, которые изменяют словарный объект на месте.
5. Почему вы можете использовать словарь вместо списка?
Проверьте свои знания: ответы
1. Список из пяти нулей создадут литеральное выражение вроде [ 0, 0, 0, 0, 0 ]

и выражение повторения наподобие [0] *5. На практике вы можете также пост-
роить такой список с помощью цикла, который начинает с пустого списка и на

каждой итерации добавляет к нему 0 посредством L. append (0). Здесь могло бы
подойти и списковое включение ([0 for i in range (5) ]), но с ним связано
больше работы, чем стоит делать в ответе на этот простой вопрос.
2. Желаемый словарь создадут литеральное выражение, такое как
{'а1: 0, ’ b ’ : 0}, или серия присваиваний вроде D = { }, D [ ’ а ’ ] = 0

и D[ ’Ь’ ] = 0. Вы также можете применять более новую и простую в набо-
ре форму ключевого слова diet (а=0, Ь=0) или более гибкую форму последо-
вательности “ключей/значений” diet ( [ (’а’, 0) , (1 b’, 0) ] ). Либо из-за того,

что все значения одинаковы, вы можете использовать специальную форму

diet. fromkeys (’ab’, 0). В Python З.Х и 2.7 вы также можете применять вклю-
чение словаря: { к: 0 for к in ’ ab1 }, хотя здесь оно снова может оказаться

излишеством.
3. Методы append и extend увеличивают список на месте, методы sort и reverse

упорядочивают и обращают списки, метод insert вставляет элемент по смеще-
нию, методы remove и pop удаляют элемент из списка по значению и по пози-
ции, оператор del удаляет элемент или срез, а операторы присваивания по ин-
дексам и по срезам заменяют элемент или целую секцию. Для ответа на данный

вопрос выберите любые четыре операции из перечисленных.

4. Словари изменяются главным образом путем присваивания по новому или су-
ществующему ключу, что создает либо изменяет запись в таблице, связанную с

этим ключом. Кроме того, оператор del удаляет запись ключа, словарный метод
update объединяет один словарь с другим на месте и метод D.pop (key) удаляет
ключ и возвращает значение, которое он имел. У словарей также есть прочие
более экзотические методы, не рассмотренные в главе, такие как setdefault;
подробные сведения ищите в справочниках.

5. Словари обычно лучше, когда данные помечены (например, запись с именован-
ными полями), а списки больше подходят для коллекций непомеченных данных

(таких как все файлы в каталоге). Поиск в словаре, как правило, быстрее поиска
в списке, хотя это может варьироваться в зависимости от программы.



Запомните в качестве эмпирического правила, что списки являют-
ся предпочтительным инструментом для упорядоченных коллекций, которые могут

нуждаться в изменении, а кортежи способны справиться с другими сценариями фик-
сированных объединений.
