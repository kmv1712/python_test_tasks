стр.205

Резюме

В главе был проведен экскурс в типы числовых объектов Python и операции, кото-
рые к ним можно применять. Попутно мы исследовали стандартные целочисленные

типы и типы с плавающей точкой, а также ряд более экзотических и менее распро-
страненных типов наподобие комплексных чисел, десятичных чисел, дробей и мно-
жеств. Мы обсудили синтаксис выражений Python, преобразования между типами,

побитовые операции и разнообразные литеральные формы для записи чисел в сце-
нариях.

Далее в этой части книги мы продолжим подробный обзор типов, восполняя не-
достающие детали об очередном типе объектов — строке. Однако в следующей главе

мы займемся исследованием присваивания переменных. Оно представляет собой, по-
жалуй, наиболее фундаментальную идею в Python, поэтому обязательно ознакомьтесь

со следующей главой, прежде чем двигаться дальше. А сейчас наступило время для
традиционных контрольных вопросов.
Проверьте свои знания: контрольные вопросы
1. Каким будет значение выражения 2 * (3 + 4) в Python?
2. Каким будет значение выражения 2 ★ 3 + 4 в Python?
3. Каким будет значение выражения 2 + 3 * 4 в Python?
4. Какие инструменты можно использовать для нахождения квадратного корня и
квадрата числа?
5. Каким будет тип результата выражения 1 + 2 . О + 3?
6. Как можно усекать и округлять число с плавающей точкой?
7. Как можно преобразовывать целое число в число с плавающей точкой?
8. Как можно отображать целое число в восьмеричной, шестнадцатеричной или
двоичной форме?
9. Как можно преобразовывать строку восьмеричных, шестнадцатеричных или
двоичных цифр в простое целое число?
Проверьте свои знания: ответы

1. Значением выражения будет 14, результат 2*7, поскольку круглые скобки при-
водят к выполнению сложения раньше умножения.

2. Значением выражения будет 10, результат 6 + 4. В отсутствие круглых скобок

применяются правила старшинства операций Python, а согласно табл. 5.2 умно-
жение имеет более высокий приоритет, чем сложение.

3. Значением выражения будет 14, результат 2 + 12, по тем же причинам старшин-
ства, что и в предыдущем ответе.

Глава 5. Числовые типы 205

4. Функции для получения квадратного корня, а также числа пи, тангенсов и мно-
гого другого доступны в импортируемом модуле math. Чтобы найти квадратный

корень числа, импортируйте math и вызовите math, sqrt (N). Для нахождения
квадрата числа используйте либо выражение возведения в степень X * * 2, либо
встроенную функцию pow (X, 2). Любой из двух последних приемов позволяет
также вычислить квадратный корень в случае указания степени 0.5 (например,
X** .5).

5. Результатом будет число с плавающей точкой: целые числа преобразуются в чис-
ла с плавающей точкой (наиболее сложный тип в выражении) и для вычисления

применяется математика с плавающей точкой.

6. Усечение производят функции int (N) и math, trune (N), а округление — функ-
ция round (N, digits). Можно также округлять в меньшую сторону с помощью

math, floor (N) и округлять для отображения посредством операций формати-
рования строк.

7. Функция float (I) преобразует целое число в число с плавающей точкой; сме-
шивание целых чисел и чисел с плавающей точкой внутри выражения также

приводит к преобразованию. В определенном смысле операция деления / из

Python З.Х также производит преобразование — она всегда возвращает резуль-
тат, который содержит остаток, даже если оба операнда являются целыми.

8. Встроенные функции oct (1) и hex (I) возвращают для целого числа строковые
представления в восьмеричной и шестнадцатеричной формах. Вызов bin (I)

возвращает строку с двоичными цифрами в Python 2.6, 3.0 и последующих вер-
сиях. Операция форматирования строк % и строковый метод format также поз-
воляют выполнять подобные преобразования.

9. Для преобразования строк восьмеричных, шестнадцатеричных и двоичных
цифр в нормальные целые числа можно использовать функцию int (S, base),
передавая ей в качестве основания системы счисления (base) соответственно
8, 16 и 2. Для той же самой цели можно применять и функцию eval (S), но она
сопряжена с более высокими затратами и проблемами в плане безопасности.
Обратите внимание, что в памяти компьютера целые числа всегда хранятся в
двоичной форме; преобразования происходят просто в целях отображения.

стр.218

Резюме
В главе мы более подробно рассмотрели модель динамической типизации Python —
т.е. способ, которым Python автоматически отслеживает типы объектов, не требуя от
нас написания операторов объявлений в сценариях. Попутно вы узнали, каким образом
переменные и объекты связываются ссылками в Python; также обсуждалась идея сборки

мусора, было показано, как разделяемые ссылки могут влиять на множество перемен-
ных, и приведены объяснения воздействия ссылок на понятие равенства в Python.

Поскольку в Python имеется лишь одна модель присваивания и оттого, что при-
сваивание вездесуще в языке, важно понять данную модель, прежде чем двигаться

дальше. Следующие контрольные вопросы должны помочь вам закрепить некоторые

идеи, изложенные в главе. Затем мы возобновим наш тур по основным объектам, пе-
рейдя к рассмотрению строк.

Проверьте свои знания: контрольные вопросы
1. Взгляните на следующие три оператора. Изменяют ли они значение, выводимое для А?
А = "spam”
В - А
В = "shrubbery"

2. Взгляните на приведенные ниже три оператора. Изменяют ли они значение, вы-
водимое для А?

А = ["spam"]
В = А
В[0] = "shrubbery"
3. Как насчет показанных далее трех операторов — изменяется ли А теперь?
А= ["spam"]
В = А[:]
В[0] = "shrubbery"

Проверьте свои знания: ответы
1. Нет: для А по-прежнему выводится "spam". Когда В присваивается строка

"shrubbery", все что происходит — переменная В переустанавливается для ука-
зания на новый строковый объект. А и В изначально разделяются, т.е. указывают

на тот же самый одиночный строковый объект "spam", но в Python два имени
никогда не связываются вместе. Таким образом, установка В в другой объект не
оказывает влияния на А. Кстати, то же самое справедливо, если бы последним

оператором здесь был В == В + ' shrubbery’ — конкатенация привела бы к созда-
нию в качестве своего результата нового объекта, который затем был бы при-
своен только В. Мы не можем перезаписывать строку (либо число или кортеж)

на месте, потому что строки неизменяемы.

2. Да: теперь для А выводится [ "shrubbery" ]. Формально мы на самом деле не из-
меняем ни А, ни В; взамен мы модифицируем часть объекта, на который ссыла-
ются обе переменные (указывают на него), перезаписывая этот объект на месте

через переменную В. Поскольку А ссылается на тот же самый объект, что и В,
обновление отражается также в А.
3. Нет: для А по-прежнему выводится [ "spam" ]. Присваивание на месте через В на

этот раз не оказывает воздействия, т.к. выражение среза создает копию списко-
вого объекта до его присваивания переменной В. После второго оператора при-
сваивания существуют два разных списковых объекта, которые имеют одинако-
вые значения (в Python они дают True при выполнении операции ==, но не is).

Третий оператор изменяет значение спискового объекта, на который указывает В,
но не того, на который указывает А.
