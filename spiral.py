# Выведите таблицу размером n×n, заполненную целыми числами от 1 до n2 по спирали, выходящей из левого верхнего угла и закрученной по часовой стрелке, как показано в примере.
# 
# Формат ввода:
# Одна строка, содержащая одно целое число n, n>0.
# 
# Формат вывода:
# Таблица из n строк, значения в строках разделены пробелом.
# 
# Sample Input:
# 
# 5
# Sample Output:
#
# 1   2  3  4  5 6
# 20 21 22 23 24 7
# 19 32 33 34 25 8
# 18 31 36 35 26 9
# 17 30 29 28 27 10
# 16 15 14 13 12 11

# strin_input = 6
# strin_input = 5
# strin_input = 5
# strin_input = 4
# strin_input = 4
# strin_input = 3
# strin_input = 3
# strin_input = 2
# strin_input = 2
# strin_input = 1
# strin_input = 1
#
# # 1   2  3  4 5
# # 16 17 18 19 6
# # 15 24 25 20 7
# # 14 23 22 21 8
# # 13 12 11 10 9
#
# strin_input = 5
# strin_input = 4
# strin_input = 4
# strin_input = 3
# strin_input = 3
# strin_input = 2
# strin_input = 2
# strin_input = 1
# strin_input = 1
#
# # 1  2  3  4
# # 12 13 14 5
# # 11 16 15 6
# # 10 9  8  7
#
# strin_input = 4
# strin_input = 3
# strin_input = 3
# strin_input = 2
# strin_input = 2
# strin_input = 1
# strin_input = 1
#
# # 1 2 3
# # 8 9 4
# # 7 6 5
#
# strin_input = 3
# strin_input = 2
# strin_input = 2
# strin_input = 1
# strin_input = 1
#
# # 1 2
# # 4 3
#
# strin_input = 2
# strin_input = 1
# strin_input = 1
#
#
# [
#     [0, 0, 0, 0, 0, 0],
#     [1, 1, 1, 1, 1, 1],
#     [2, 2, 2, 2, 2, 2],
#     [3, 3, 3, 3, 3, 3],
#     [4, 4, 4, 4, 4, 4]
#     [4, 4, 4, 4, 4, 4]
# ]
#
#
# [
#     [0, 0, 0, 0, 0],
#     [1, 1, 1, 1, 1],
#     [2, 2, 2, 2, 2],
#     [3, 3, 3, 3, 3],
#     [4, 4, 4, 4, 4]
# ]
#
# [
#     [0, 0, 0, 0],
#     [1, 1, 1, 1],
#     [2, 2, 2, 2],
#     [3, 3, 3, 3],
# ]
#
#
# end_value = string_input * string_input
#
# start_v = 1
# end_v = start_v + 1
# i_horizon = 0
# i_vertical = 0
# s = string_input
#
# # Получим координату последнего элемента улитки
# import math
# string_input = int(input())
# if string_input % 2 == 1:
#     index_end_row = math.ceil(string_input / 2) - 1
#     index_end_col = math.ceil(string_input / 2) - 1
# elif string_input % 2 == 0:
#     index_end_row = (string_input / 2) - 1
#     index_end_col = (string_input / 2)
#
# matrix = [[item for item_one in range(string_input)] for item in range(string_input)]
# end_value = string_input * string_input
#
# for i, item in enumerate(range(end_value, 0, -1)):
#     matrix[index_end_col][index_end_row] = item
#
# for i, item in enumerate(range(1, 26)):
#     print('{0} : {1}'.format(i, item))




        # 1.Каждый угловой элемент «улитки» (тот элемент, на котором происходит очередной поворот) можно легко рассчитать по формуле, зная размерность матрицы и номер шага:

# C = l * s — M;

# l — размерность
# s — номер шага
# M — смещение

# Смещение — это сдвиг от «края» матрицы. Ведь на каждой итерации угловые элементы приближаются к центру.
# Соответственно, он меняется с каждым шагом. Изначально он равен 0. Для следующего шага (s+1) он рассчитывается так:
#
# M = M + delta;

# 5 * 1 - 0 = 5                  s = 1 M = 0
# 5 * 2 - 1 = 9                  s = 2 M = 1 
# 5 * 3 - 2 = 13                 s = 3 M = 2
# 5 * 4 - 4 = 16                 s = 4  M = 4
# 5 * 5 - 6 = 19                 s = 5 M = 6
# 5 * 6 - 8 = 22                 s = 6 M = 8
# 5 * 5 - 6 = 19                 s = M = 6
# 5 * 5 - 6 = 19                 s = M = 6


#
# if(s % 2 != 0)
#  delta = math.ceil(s / 2)
#
# s — номер шага

#st - текущее значение-счетчик для записи в матрицу
#m - коеффициент, используемый для заполнения верхней
#матрицы последующих витков, т.к. одномерные матрицы
#следующих витков имеют меньше значений

# Создаётся функция, которая и будет всё делать
def spiral(matrix_dimension):
    # Переменной dx присваивается значение 1
    # Переменной dy присваивается значение 0
    # Обычно dx и dy - это некие приращения для переменных x и y
    dx, dy = 1, 0
    # Переменным x и y присваивается значение 0
    x, y = 0, 0
    # Создаётся список списков
    # Это матрица n*n
    # Пока все её элементы - пустые (None)
    # матрица построена |||||
    matrix = [[0] * matrix_dimension for _ in range(matrix_dimension)]
    # Выполняется перебор
    # Для переменной i последовательно перебираем значения от 1 до (n-квадрат + 1)
    for i in range(1, matrix_dimension**2+1):
        # Элементу матрицы с координатами x и y присваивается значение i
        # Эта строчка будет присваивать последовательные натуральные числа
        # тем ячейкам, которые перебирает код чуть ниже
        matrix[x][y] = i
        # Создаются временные переменные new_x и new_y
        # в которых вычисляются новые значения для x и y
        # для этого к старым значенииям прибавляются приращения
        new_x, new_y = x+dx, y+dy
        # Если всё нормально, и индекс не выскочил за пределы матрицы
        # или не наткнулся на уже занятую ячейку
        if 0 <= new_x < matrix_dimension and 0 <= new_y < matrix_dimension and not matrix[new_x][new_y]:
            # то эти значения и оставляются
            x, y = new_x, new_y
        else:
            # а если индекс выскочил за границу матрицы
            # или наткнулся на уже занятую ячейку
            # то разворачиваемся на 90 градусов
            # путем замены приращения по x и y друг на друга
            # а минус нужен, чтобы он не ходил только вправо или вниз,
            # а чередовал с движениями вверх или влево.
            # Так и получается спираль
            dx, dy = -dy, dx
            # и используем уже это изменённое движение для новых значений x и y
            x, y = x+dx, y+dy
    # После того, как перебрали все элементы,
    # печатаем то, что получилось
    for x in list(zip(*matrix)):
        print(*x)

# А здесь вся вышеописанная функция
# вызывается с аргументом, который вводит пользователь с клавиатуры
spiral(int(input()))
