Учим django

Создадим виртуальную среду с названием env.
python3 -m venv env

Активируем виртуальную среду.
source env/bin/activate

Установим библиотеку django в активированую виртуальную среду.
pip install django

Запустим проект django с именем samplesite.
django-admin startproject samplesite

Записать установленные библиотеки в requirement.txt
pip freeze > requirement.txt

Загрузить в проект библиотеки из requirement.txt
pip install -r requirements.txt

Создать новое пустое приложение с именем bboard 
 ./manage.py startapp bboard

Добавить созданое приложение в INSTALLED_APPS
'bboard.apps.BbordConfig'

Запустим генерирование миграции
./manage.py makemigrations bboard

Посмотреть сгенерированый код для СУБД на SQL
./manage.py sqlmigrate bboard 0001

Выполнить сгенерированную миграцию.
./manage.py migrate

Выполнить сгенерированную миграцию.
./manage.py shell


1.5.Контроллеры
Контроллер Django(view) - это код, запускаемый в ответ на поступление клиентского запроса, который сожержит интернет-адрес определенного формата. Именно в контроллерах выполняются все действия по подготовке данных для вывода, равно как и обработка данных, поступивших от посетителя  

1.6. Маршруты и маршрутизатор.
Файлы urls

Создадим в файле bboard файл urls.py и укажем 

from django.urls import path

from .views import index

urlpatterns = [
    path('', index),
]

Поправим основной шаблон urls.py 
from django.contrib import admin
from django.urls import path, include

from bboard.views import index

urlpatterns = [
    path('bboard', include('bboard.urls'))
    path('admin/', admin.site.urls),
]


1.7.Модели.
Сама модель должна быть подкласом класса Model

Примеры типов
CharField - обычное строковое поле фиксированной длинны max_length(макс. кол-во символов)
TextField - текстовое поле не ограниченной длины, или memo-поле() null=True, blank=True(значит поле можно не заполнять).
FloatField
DateTimeField

Если указать db_index=True, то поле станет индексируемым.

В Django поле для идентификаторов объявлять не надо.

1.8. Миграции

Миграции - это модуль Python, созданный самим Django на основе определенной модели и предназначенный для формирования в базе данных всех требуемых этой моделью структур: таблиц, полей, индексов, правил и связей.


1.9. Консоль Django

От консоли python shell отличается тем что в ней в состав путей поиска модулей добавляется путь к папке проекта, в которой запущена эта консоль.

1.10. Работа с моделями.

from bboard.models import Bd
b1 = Bd(title='Дача', content='Общество \"Двухэтажники\" Два этажа, кирпич, свет, газ, канализация', price=500000)

Созданная таким образом запись не сохраняется в базе данных, а существует только в оперативной памяти. Чтобы сохранить ее, достаточно вызвать у нее метод save() без параметров:
b1.save()

Поверим сохранилось ли наше объявление, получив значение ключевого поля
b1.pk

Отлично! Сохранилось.

>>> b2 = Bd()
>>> b2.title = 'Автомобиль'
>>> b2.content = '"Жигули"'
>>> b2.save()
>>> b2.pk

>>> b2.content = '\"Жигули\", 1980 года, ржавая, некрашенная, сильно битая'
>>> b2.save()
>>> b2.content

Добавим еще объявление.
>>> Bd.objects.create(title='Дом', content='Трехэтажный кирпич', price=50000000)

Все классы моделей подерживают атрибуты класса objects. Он хранит диспетчер записей - особую структуру, позволяющую манипулировать всей совокупностью имеющихся в модели записей. Диспетчер записей представляется экземпляром класа Manager.

Метод create() диспетчер записей создает новую запись модели, принимая в качестве набора именнованных параметров значение ее полей. При этом он сразу же сохраняет созданную запись и возвращает в качестве результата.

 for b in Bd.objects.all():
...     print(b.pk, ': ', b.title)
... 

Метод all() - диспетчер записей, возвращает набор записей, содержит записи модели, в нашем случае все, что есть в БД. Сам набор записей представляется экземпляром класса QuerySet, а отдельные записи - экземплярами соответсвующиго класса модели. 

for b in Bd.objects.order_by('title'):
...     print(b.pk, ': ', b.title)
... 

Метод order_by() - сортирует записии по значению поля, чье имя указано в параметре, и сразу же возвращает получившийся в результате сортировки набор записей.

for b in Bd.objects.filter(title='Дом'):
    print(b.pk, ': ', b.title)

Метод filter() диспетчер записей выполняет фильтрацию записей по заданным критериям. В часности, чтобы получить только записи, у которых определенное поле содержит заданное значение , следует указать в вызове этого метода именнованный парамметр, чье имя совпадает с именем поля, и присвоить ему значение, которое должно содержаться в указаном поле. Метод возвращает другой диспетчер записей, содержащий только отфильтрованные записи.

Объявление о автомобиле имеет ключ 2. Отыщем его:

>>> Ь = Bd.objects.get(pk=2)
>>> b.title
'Автомобиль'
>>> b.content
'"Жигули", 1980 года, ржавая, некрашеная, сильно битая'

Метод get() диспетчера записей имеет то же назначение, что и метод filter() ,
и вызывается аналогичным образом. Однако он ищет не все записи, подходящие
под заданные критерии, а лишь одну и возвращает ее в качестве результата. К тому
же, он работает быстрее метода filter ().

>>> b.delete ()
( 1, { 'bboard. ВЬ' : 1 } )

Метод delete () модели, как уже понятно, удаляет текущую запись и возвращает
сведения о количестве удаленных записей, обычно малополезные.

