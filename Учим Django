Учим django

Создадим виртуальную среду с названием env.
python3 -m venv env

Активируем виртуальную среду.
source env/bin/activate

Установим библиотеку django в активированую виртуальную среду.
pip install django

Запустим проект django с именем samplesite.
django-admin startproject samplesite

Записать установленные библиотеки в requirement.txt
pip freeze > requirement.txt

Загрузить в проект библиотеки из requirement.txt
pip install -r requirements.txt

Создать новое пустое приложение с именем bboard 
manage.py startapp <имя приложения> [<путь к папке пакета приложения>]Ж
 ./manage.py startapp bboard

Добавить созданое приложение в INSTALLED_APPS
'bboard.apps.BbordConfig'

Запустим генерирование миграции
manage.py makemigrations [<список псевдонимов прил жений, разделенных
пробелами>] [--name 1-n <имя миrрации>] [--noinput] [--no-input]
[--dry-run] [--check] [--merge] [--empty]

./manage.py makemigrations bboard

Посмотреть сгенерированый код для СУБД на SQL
./manage.py sqlmigrate bboard 0001

Выполнить сгенерированную миграцию.
./manage.py migrate

Выполнить сгенерированную миграцию.
./manage.py shell

Слияния миграций:
manage. ру squashrnigrations <псевдоним приложения> [<имя первой миграции>]
<имя последней миграции> [ --squashed _ name <имя результирующей миграции>]
[--no-optimize] [--noinput] [--no-input]

Просмотреть список всех миграций, нмеющихся в проекте:
manage.py showmigrations [<список псевдонимов приложений, разделенных
пробелами>] [ --plan] [ -р]

manage. ру runserver [ [<интернет-адрес>] [:] [<порт>] ] [ --noreload]
[--nothreading] [--ipvб] [-6]

Команда runserver поддерживает следующие дополнительные ключи:

--noreload - отключить автоматический перезапуск при изменении программ-
ного кода;
--nothreading - принудительный запуск отладочного сервера в однопоточном
режиме (если ключ не указан, сервер запускается в много поточном режиме);
--ipvб или -6 - использовать протокол 1Pv6 вместо 1Pv4. В этом случае по
умолчанию будет использоваться интернет-адрес ::1.

Для удаления всех миграций надо выполнить команду migrate утилиты manage.py, указав в ней имя нужного приложения
и zero в качестве имени миграции.
manage.py migrate testapp zero

стр 382 МНожественное сохранение изображений.

4.3.1. Справочник парамметров модели стр.91
4.3.2. Справочник по типам полей модели стр.95
4.4. Справочник по созданию связей между моделями.
4.5. Параметры самой модели (атрибуты класса Meta стр 103
4.6. Интернет адрес модели и его формирование
Декларативный или императивный метод
4.7. Методы модели стр 107
4.8. Валидация модели стр.109
4.8.2. Вывод собственных сообщений об ошибках. стр.113

Глава 5. Миграции
Миграция - это программный модуль, создающий в базе данных все необходимые
для модели структуры: таблицы, поля, индексы, правила и связи. При выполнении
миграция генерирует SQL-кoд, выполняющий создание этих структур и рассчитанный
5.1. Формирование мограций расшифровка доп возм makemigrations
5.2. Файлы миграции
5.3. Выполнение миграций
5.4. Слияние миграций.
5.5. Вывод спискамиграций
5.6. Отмена всех миграций
Глава 6 Запись Данных
6.1. Правка записей
6.2. Создание записей . (Создать запись можно тремя способами)
6.3. Некоторые замечания о методе save()
6.4. Удаление записей.
6.5. Особенности обработки связанных записей.
6.7. МАссовая запись данных стр.130
6.8. Выполнение валидации модели
Глава 7. Выборка данных.
7.1. Извлечение значений из полей записи.
7.2. Доступ к связанным записям
7.3. Выборка записей.
7.3.1. Выборка всех записей.
7.3.2. Извлечение одной записи
7.3.3. Получение количества записей в наборе.
7.3.4. Поиск записи.
7.3.5. Фильтрация записей
7.3.6. Написание условий фильтрации. (перечень модификаторов exact, iexact, contains)
7.3.7. Фильтрация по значениям полей связанных записей.
7.3.8. Сравнение со значениями других полей 144
7.3.9. Сложные условия фильтрации 144
7.3.10 Выборка уникальных записей 145
7.3.11 Выборка указанного количества записей
7.4. Сортировка записей
7.5. Агрегатные вычислления 147
7.5.1. Вычисления по всем записям модели
7.5.2. Вычисления по группам записей.
7.5.3. Агрегатные функции
7.6. Вычисляемые поля.
7.6.1. Простейшие вычисляемые поля
7.6.4. Вложенные запросы
7.7. Объединение наборов записей.
7.8. Извлечение значений только из заданнных полей.
7.9. Получение значения из полей со списком.
Глава 8 Маршрутизация.
Маршрутизация в терминах Django - это процесс выяснения, какой контроллер
следует выполнить при получении в составе клиентского запроса интернет-адреса
определенного формата . Подсистема фреймворка, выполняющая маршрутизацию,
носит название маршрутизатора.
8.1. Как работает маршрутизатр
8.2.
8.3. Объявлени маршрутов.
8.6. Пространство имен. Коревое приложение


1.5.Контроллеры
Контроллер Django(view) - это код, запускаемый в ответ на поступление клиентского запроса, который сожержит интернет-адрес определенного формата. Именно в контроллерах выполняются все действия по подготовке данных для вывода, равно как и обработка данных, поступивших от посетителя  

1.6. Маршруты и маршрутизатор.
Файлы urls

Создадим в файле bboard файл urls.py и укажем 

from django.urls import path

from .views import index

urlpatterns = [
    path('', index),
]

Поправим основной шаблон urls.py 
from django.contrib import admin
from django.urls import path, include

from bboard.views import index

urlpatterns = [
    path('bboard', include('bboard.urls'))
    path('admin/', admin.site.urls),
]


1.7.Модели.
Сама модель должна быть подкласом класса Model

Примеры типов
CharField - обычное строковое поле фиксированной длинны max_length(макс. кол-во символов)
TextField - текстовое поле не ограниченной длины, или memo-поле() null=True, blank=True(значит поле можно не заполнять).
FloatField
DateTimeField

Если указать db_index=True, то поле станет индексируемым.

В Django поле для идентификаторов объявлять не надо.

1.8. Миграции

Миграции - это модуль Python, созданный самим Django на основе определенной модели и предназначенный для формирования в базе данных всех требуемых этой моделью структур: таблиц, полей, индексов, правил и связей.


1.9. Консоль Django

От консоли python shell отличается тем что в ней в состав путей поиска модулей добавляется путь к папке проекта, в которой запущена эта консоль.

1.10. Работа с моделями.

from bboard.models import Bd
b1 = Bd(title='Дача', content='Общество \"Двухэтажники\" Два этажа, кирпич, свет, газ, канализация', price=500000)

Созданная таким образом запись не сохраняется в базе данных, а существует только в оперативной памяти. Чтобы сохранить ее, достаточно вызвать у нее метод save() без параметров:
b1.save()

Поверим сохранилось ли наше объявление, получив значение ключевого поля
b1.pk

Отлично! Сохранилось.

>>> b2 = Bd()
>>> b2.title = 'Автомобиль'
>>> b2.content = '"Жигули"'
>>> b2.save()
>>> b2.pk

>>> b2.content = '\"Жигули\", 1980 года, ржавая, некрашенная, сильно битая'
>>> b2.save()
>>> b2.content

Добавим еще объявление.
>>> Bd.objects.create(title='Дом', content='Трехэтажный кирпич', price=50000000)

Все классы моделей подерживают атрибуты класса objects. Он хранит диспетчер записей - особую структуру, позволяющую манипулировать всей совокупностью имеющихся в модели записей. Диспетчер записей представляется экземпляром класа Manager.

Метод create() диспетчер записей создает новую запись модели, принимая в качестве набора именнованных параметров значение ее полей. При этом он сразу же сохраняет созданную запись и возвращает в качестве результата.

 for b in Bd.objects.all():
...     print(b.pk, ': ', b.title)
... 

Метод all() - диспетчер записей, возвращает набор записей, содержит записи модели, в нашем случае все, что есть в БД. Сам набор записей представляется экземпляром класса QuerySet, а отдельные записи - экземплярами соответсвующиго класса модели. 

for b in Bd.objects.order_by('title'):
...     print(b.pk, ': ', b.title)
... 

Метод order_by() - сортирует записии по значению поля, чье имя указано в параметре, и сразу же возвращает получившийся в результате сортировки набор записей.

for b in Bd.objects.filter(title='Дом'):
    print(b.pk, ': ', b.title)

Метод filter() диспетчер записей выполняет фильтрацию записей по заданным критериям. В часности, чтобы получить только записи, у которых определенное поле содержит заданное значение , следует указать в вызове этого метода именнованный парамметр, чье имя совпадает с именем поля, и присвоить ему значение, которое должно содержаться в указаном поле. Метод возвращает другой диспетчер записей, содержащий только отфильтрованные записи.

Объявление о автомобиле имеет ключ 2. Отыщем его:

>>> Ь = Bd.objects.get(pk=2)
>>> b.title
'Автомобиль'
>>> b.content
'"Жигули", 1980 года, ржавая, некрашеная, сильно битая'

Метод get() диспетчера записей имеет то же назначение, что и метод filter() ,
и вызывается аналогичным образом. Однако он ищет не все записи, подходящие
под заданные критерии, а лишь одну и возвращает ее в качестве результата. К тому
же, он работает быстрее метода filter ().

>>> b.delete ()
( 1, { 'bboard. ВЬ' : 1 } )

Метод delete () модели, как уже понятно, удаляет текущую запись и возвращает
сведения о количестве удаленных записей, обычно малополезные.

1.11.Шаблоны.

Аналогично for .. in ... в python
{% for bb in bbs %}
...
{% endfor %}

Достать title из объекта bb
{{ bb.title }}

Преобразует дату в заданный формат.
<p>{{ bb.published|date:"d.m.Y H:i:s" }}</p> 

Рендеринг шаблонов. Сокращения

Контекстом шаблона называется набор данных, которые должны быть доступны внутри шаблона в виде переменных и с которыми шаблонизатор объеденит этот шаблон для получения выходного документа.


1.13 Административный веи-сайт Django

LANGUAGE_CODE = 'ru-ru'
Открыть admin.py

1.14 Параметры полей и моделей.

verbose_name. Он указывает человеческое название поля, которое
verbose _name_plural множественое 

будет выводиться на экран.

class Bd(models.Model):
    title = models.CharField(max_length=50, verbose_name='Товар')
    content = models.TextField(null=True, blank=True, verbose_name='Описание')
    price = models.FloatField(null=True, blank=True, verbose_name='Цена')
    published = models.DateTimeField(auto_now_add=True, db_index=True, verbose_name='Опубликовано')

    class Meta:
        verbose_name_plural = 'Объявления'
        verbose_name = 'Объявление'
        ordering = ['-published']

ordering - Последовательность полей, по которым по умолчанию будет выполнятся сортировка

1.15. Редактор модели

Представление модели на административном сайте по умолчанию. Если же
оно нас не устраивает, мы можем задать свои параметры представления модели,
объявив для нее класс-редактор.

from django . contrib import admin
from .models import ВЬ
    class BbAdmin(admin.ModelAdmin):
        list_display = ('title', 'content', 'price', 'published')
        list_display_links = ('title', 'content')
        search_fields = ('title', 'content', )
        admin.site.register(Bb, BbAdmin)

- list_displa у - последовательность имен полей, которые должны выводиться
в списке записей;
- list_display_links - последовательность имен полей, которые должны быть
преобразованы в гиперссылки, ведущие на страницу правки записи;
- search_fields - последовательность имен полей, по которым должна вьшол-
няться фильтрация.

2.1. СВЯЗИ МЕЖДУ МОДЕЛЯМИ.
Таким образом будет создана
связь «один-со-многими», при которой одна запись модели RuЬric (рубрика) будет

связана с произвольным количеством записей модели вь (объявлений). Профессио-
налы в области баз данных скажут при этом, что модель RuЬric станет первичной,

а модель вь - вторичной.
class Bd(models.Model):
    title = models.CharField(max_length=50, verbose_name='Товар')
    content = models.TextField(null=True, blank=True, verbose_name='Описание')
    price = models.FloatField(null=True, blank=True, verbose_name='Цена')
    published = models.DateTimeField(auto_now_add=True, db_index=True, verbose_name='Опубликовано')
    !rubric = models.ForeignKey('Rubric', null=True, on_delete=models.PROTECT, verbose_name='РУбрика')

    class Meta:
        verbose_name_plural = 'объявления'
        verbose_name = 'объявление'
        ordering = ['-published']

class Rubric(models.Model):
    name = models.CharField(max_length=20, db_index=True, verbose_name='Название')

    class Meta:
        verbose_name_plural = 'Рубрики'
        verbose_name = 'Рубрика'
        ordering = ['name']


Класс ForeignКey представляет поле внешнего ключа, в котором фактически будет
храниться ключ записи из первичной модели.

Все поля, создаваемые в моделях, по умолчанию обязательны к заполнению. Сле-
довательно, добавить новое, обязательное к заполнению поле в модель, которая

уже содержит записи, нельзя - сама СУБД откажется делать это и выведет сооб-
щение об ошибке. Нам придется явно пометить поле ruЬric как необязательное,

присвоив параметру null значение тrue - только после этого поле будет успешно
добавлено в модель.

Именованный параметр on _ delete управляет каскадными удалениями записей
вторичной модели после удаления записи первичной модели, с которой они бьmи
связаны. Значение РRОТЕСТ этого параметра запрещает каскадные удаления (чтобы

какой-нибудь несообразительный администратор не удалил разом сразу уйму объ-
явлений).

2.2. Строковое представление модели

Можно определить поля в admin.py
class RubricAdmin(admin.ModelAdmin):
    list_display = ('name',)
    list_display_links = ('name',)
    search_fields = ('name',)

admin.site.register(Rubric, RubricAdmin)

но если поле всего одно то можно в models.py, переопределить метод __str__ 
class RuЬric(models.Model):
    ...
    def __str__(self):
        return self.name
    class Meta:
    ...


2.3. URL-парметры и параметризованные запросы
from .views import index, Ьy_ruЬric
urlpatterns = [
path( '<int:ruЬric_id>/', Ьy_ruЬric),
path (' ', index),

Мы добавили в начало набора маршрутов еще один, с шаблонным интернет-
адресом <int:ruЬric_id>/. В нем угловые скобки обозначают описание URL-пара-
метра, языковая конструкция int - целочисленный тип этого параметра, а

ruЬric _ id - имя параметра контроллера, которому будет присвоено значение этого
URL-параметра. Созданному маршруту мы сопоставили контроллер-функцию
by_ruЬric(), который вскоре напишем.

Кстати, маршруты, содержащие URL-параметры, носят название параметризо-
ванных.

2.4. Обратное разрешение интернет-адресов
Чтобы реализовать обратное разрешение, нам следует выполнить два действия.

Первое: дать нужным маршрутам имена, создав тем самым именованные маршру-
ты. Огкроем модуль urls.py пакета приложения и исправим код, создающий набор

маршрутов, следующим образом (добавленный код выделен полужирным шриф-
том):

urlpatterns = [
path ( '<int: ruЬric_id>/', by_ruЬric, name='Ьy_ruЬric'),
path (' ', index. name='index'),

2.5. Формы связанные с моделями.

fr·om django. forms import Mode!Form
frorn .models import ВЬ
class BbForm (Mode!Form) :
class t1e ta:
model = ВЬ
fields = ('title', 'content', 'price', 'ruЬric')
Класс формы, связанной с моделью, является производным от класса Mode!Form из

модуля django. forms. В классе формы мы объявили вложенный класс Meta, в кото-
ром указали параметры нашей формы: класс модели, с которой она связана (атри-
бут класса model), и последовательность из имен полей модели, которые должны

присутствовать в форме (атрибут класса fields).

2.6. Контроллеры-классы
from django.urls import reverse_lazy
class BbCreateView(CreateView):
    success url reverse_lazy('index')

2.7. Наследование шаблонов.
В самом начале кода mобого производного шаблона должен стоять тег шаблониза-
тора extends, после котuрого записывается путь к базовому шаблону.

2.8. Статические файлы.
Файлы, содержимое которых не обрабатывается программно, а пересьmается
клиенrу как есть, в терминологии Django носят название статических. К таким

файлам относятся, например, таблицы стилей и графические изображения, поме-
щаемые на страницы.


{% load static%}

<!DOCTYPE html> 
<html> 
<head> 
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
        <title>{% block title %}Главная{% endblock %} - Доска объявлений</title> 
        <link rel="stylesheet type="text/css" href="{% static 'bboard/style.css' %}">


Часть II
Глава 3 Создание и настройка проекта.

3.2.
При создание проекта будет создан manage.py и пакет конфигупаций, чье имя совпадает с именем проекта.

3.3.Настройка пректа.
На работу проекта значительное значение оказывают настройки в файле settings.py

3.3.1. Основные настройки.
BASE_DIR - задает путь к папке проета. По умолчанию этот путь задается автоматически.
DEBUG - 

3.3.2. Параметры баз данных.
3.3.3. Список зарегистрированных приложений.
3.3.4. Список зарегистрированных посредников


3.4. Создание, настройка и регистрация приложений
3.4.1. Создание приложений

Модели: базовые инструменты.
4.1. ВВедение в модели.
Модель - это класс, описывающий хранящуюся
в базе данных сущность и являющийся представлениями таблицы и отдельной ее
записи средствами Python.

Механизм моделей Django основывается на следующих принципах:
[] сам класс модели представляет всю совокупность сущностей, принадлежащих
этому классу и хранящихся в базе данных;

Q отдельный экземпляр класса модели представляет отдельную сущность, принад-
лежащую этому классу и извлеченную из базы данных;

[] класс модели описывает набор отдельных значений (полей), входящих в состав
сущности этого класса;

Q класс модели предоставляет инструменты для работы со всеми сущностями это-
го класса: их извлечения, фильтрации, сортировки и пр.;

[] экземпляр класса модели предоставляет инструменты для работы с отдельными
значениями, входящими в состав сущности: ее сохранения, удаления, а также
создания новых сущностей;
[] набор извлеченных из базы сущностей представляется последовательностью
экземпляров соответствующего класса модели.

4.3.1. Параметры, поддерживаемые полями всех типов.

Verbose_name
unique - есл иуказано то индекс ставится автоматически.

С модели может присутсвовать только одно ключевое слово.

4.3.2. Классы полей моделей.

4.4.1. Связь «один-со-многими»

Связь «один-со-многими» позволяет связать одну запись первичной модели с про-
извольным количеством записей вторичной модели. Эго наиболее часто применяе-
мый на практике вид связей.

4.4.2 Связь «один-с-одним» соединяет одну запись первичной модели с одной записью
вторичной модели. Такие связи служат для объединения моделей, одна из которых
хранит данные, дополняющие данные из другой модели.

4.4.3. Многие со многими

И, наконец, самая сложная в реализации (для Django - но не для нас) связь «мно-
гие-со-многими» - она позволяет связать произвольное количество записей одной

модели с произвольным количеством записей другой (обе модели здесь высrупают
как равноправные, и определить, какая из них первичная, а какая вторичная, не
представляется возможным).
Для создания такой связи нужно объявить в одной из моделей (но не в обеих сразу!)
поле внешнего ключа типа ManyТoManyField. Вот формат его конструктора:
ManyТoManyField(<втopaя связываемая модель [, остальные параметры>])

Модель, в которой было объявлено поле внешнего ключа, носит название ведущей,
а вторая модель в таком случае станет ведомой.Ярик


4.5. Параметры самой модели


Глава 6
Главное предназначение моделей упрошение работы с данными, хранящимися в информационной базе.

save(commit=False) не сохранит в бд
save_m2m() сохранить многие ко многим.

field.help_text

Пример:
>>> from bboard.models import ВЬ
>>> Ь = Bb.objects.get(pk=l)
>>> # Никаких дополнительных запросов к базе данных не вьmолняется,
>>> # т. к. значение поля title, равно как и значения всех прочих
>>> # полей текущей модели, уже извлечены
>>> b.title
'Дача'
>>> # Но для извлечения полей записи связанной модели вьmолняется
>>> # отдельный запрос к базе данных
>>> b.ruЬric.пame
'Недвижимость'
>>>#Используем метод select_related(), чтобы выбрать поля и текущей,
>>> # и связанной моделей в одном запросе
>>> Ь = Bb.objects.select_related('ruЬric') .get(pk=l)
>>> # Теперь отдельный запрос к базе для извлечения значения поля
>>> # связанной модели не вьmолняется
>>> b.ruЬric.name
'Недвижимость'



стр.438

from django.dispatch import Signal
add_bb = Signal(providing_args=['instance', 'ruЬric'])  # Создать свой сигнал
add_bb.send(Bb, instance=bb, rubric=bb.ruЬric)  # Установить его в месте в котором хочешь его отправить

def add_bb_dispatcher(sender, **kwargs):
    """Обработчик сигнала"""
    рrint('Объявление в рубрике "%s" с ценой %.2f создано' % (kwargs['rubric'] .name, kwargs['instance'] .price))

    add_bb.connect(add_bb_dispatcher) # Зацепить обработчик за сигнал
